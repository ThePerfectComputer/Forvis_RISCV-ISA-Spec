module heap:

type:
    data Color = Int (20) // this means max number of colors is 20 (??)

metadata:
    Cell Color  // data memory with a color
    Pointer Color // value with a color (assuming all values are pointers for now)
    Env   // sole PC tag (not used in any interesting way -- just here for illustration)
    Inst  // instruction  (not used at all for now)
    Alloc // the magic alloc instruction

policy:
  main =
      // putting alloc-specific rule first and using ^ means it wins over ordinary ADDI
      // 'new' is a magic built-in in dpl
      allocGrp(env == _, code == [+Alloc] -> env = env, res = {(Pointer new)})
    ^ immArithGrp(env == _, op1 == _ -> env = env, res = op1)        
    ^ arithGrp(env == _, op1 == _ -> env = env, res = op1)  
    ^ loadGrp(env == _, addr == {(Pointer color)}, mem == [+(Cell color)] ->
             env = env, res = mem[-(Cell _)])
    ^ storeGrp(env == _, addr == {(Pointer color)}, val == _, mem == [+(Cell _)] ->
              env = env, mem = val[+(Cell color)])

require:  // map external names (dotted strings) to tag sets
    init test.Cell {Cell}
    init test.Pointer {Pointer}
    init test.Env {Env}
    init test.Inst {Inst}
    init test.AllocInst {Alloc,Inst}
    init test.CP {Cell,Pointer}
// BCP: Let's try deleting this (seems superfluous)
//     init test.PC {Pointer,Cell}
//
// Needs to be modified to attach an optional int to the string on the right...

//     init test.Cell1 {Cell(1)}
// or
//     init test.Cell() {Cell()}
// There's code in PIPE.hs to do this, but it needs to be fixed to deal with tags, not tag sets
// APT: The PIPE code has now been fixed so that whenever you translate an external name
// you pass a list of (Maybe Int's) representing the optional ints to attach to each tag in the RHS tag set.
// E.g. mkTagSet policy ["test","Pointer"] [Just 42]
//      mkTagSet policy ["test","Env"] [Nothing]
//      mkTagSet policy ["test","AllocInst"] [Nothing,Nothing]


group:
    loadUpperGrp(-> RD:dest)
        lui
        auipc

    jumpGrp( -> RD:return)
        jal

    jumpRegGrp(RS1:target -> RD:return)
        jalr

    branchGrp(RS1:op1, RS2:op2 -> )
        beq
        bne
        blt
        bge
        bltu
        bgeu

    loadGrp(RS1:addr, MEM:mem -> RD:res)
        lb
        lh
        lw
        lbu
        lhu

    storeGrp(RS1:addr, RS2:val, MEM:mem -> MEM:mem)
        sb
        sh
        sw

    allocGrp (RS1:op1 -> RD:res)	// not essential to make this a separate group
        addi

    immArithGrp(RS1:op1 -> RD:res)
        addi
        slti
        sltiu
        xori
        ori
        andi
        slli
        srli
        srai
 
    arithGrp(RS1:op1, RS2:op2 -> RD:res)
        add
        sub
        sll
        slt
        sltu
        xor
        srl
        sra
        or 
        and

    systemGrp( -> )
        fence
 
    privGrp( -> )
        ecall
        ebreak

